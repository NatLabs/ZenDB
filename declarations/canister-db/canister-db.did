type ZqlOperators = 
 variant {
   In: vec Candid;
   Not: ZqlOperators;
   eq: Candid;
   gt: Candid;
   gte: Candid;
   lt: Candid;
   lte: Candid;
 };
type ZenQueryLang = 
 variant {
   And: vec ZenQueryLang;
   Operation: record {
                text;
                ZqlOperators;
              };
   Or: vec ZenQueryLang;
 };
type StableQueryPagination = 
 record {
   cursor: opt record {
                 nat;
                 PaginationDirection;
               };
   limit: opt nat;
   skip: opt nat;
 };
type StableQuery = 
 record {
   pagination: StableQueryPagination;
   query_operations: ZenQueryLang;
   sort_by: opt record {
                  text;
                  SortDirection;
                };
 };
type SortDirection = 
 variant {
   Ascending;
   Descending;
 };
type Schema = 
 variant {
   Array: CandidType;
   Blob;
   Bool;
   Empty;
   Float;
   Int;
   Int16;
   Int32;
   Int64;
   Int8;
   Map: vec record {
              text;
              CandidType;
            };
   Nat;
   Nat16;
   Nat32;
   Nat64;
   Nat8;
   Null;
   Option: CandidType;
   Principal;
   Record: vec record {
                 text;
                 CandidType;
               };
   Recursive: nat;
   Text;
   Tuple: vec CandidType;
   Variant: vec record {
                  text;
                  CandidType;
                };
 };
type Result_8 = 
 variant {
   err: text;
   ok: vec record {
             RecordId;
             CandidBlob;
           };
 };
type Result_7 = 
 variant {
   err: text;
   ok: CrossCanisterRecordsCursor;
 };
type Result_6 = 
 variant {
   err: text;
   ok: CandidBlob;
 };
type Result_5 = 
 variant {
   err: text;
   ok: RecordId;
 };
type Result_4 = 
 variant {
   err: text;
   ok: Schema;
 };
type Result_3 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_2 = 
 variant {
   err: text;
   ok: CollectionStats;
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: text;
   ok;
 };
type RecordId = nat;
type PaginationDirection = 
 variant {
   Backward;
   Forward;
 };
type MemoryStats = 
 record {
   actual_data_bytes: nat;
   metadata_bytes: nat;
 };
type KeyValuePair = 
 record {
   text;
   Candid__1;
 };
type IndexStats = 
 record {
   columns: vec text;
   stable_memory: MemoryStats;
 };
type CrossCanisterRecordsCursor = 
 record {
   collection_name: text;
   collection_query: StableQuery;
   results: Result_8;
 };
type CollectionStats = 
 record {
   indexes: vec IndexStats;
   main_btree_index: record {stable_memory: MemoryStats;};
   records: nat;
 };
type CanisterDB = 
 service {
   zendb_api_version: () -> (nat) query;
   zendb_collection_clear: (text) -> (Result);
   zendb_collection_count_records: (text, StableQuery) -> (Result_3) query;
   zendb_collection_create_index: (text, vec text) -> (Result);
   zendb_collection_delete_index: (text, vec text) -> (Result);
   zendb_collection_delete_record_by_id: (text, RecordId) -> (Result);
   zendb_collection_find_records: (text, StableQuery) -> (Result_7) query;
   zendb_collection_get_record: (text, RecordId) -> (Result_6) query;
   zendb_collection_insert_all_records: (text, vec Candid) -> (Result_5);
   zendb_collection_insert_record: (text, Candid) -> (Result_5);
   zendb_collection_insert_record_with_id: (text, RecordId, Candid) ->
    (Result);
   zendb_collection_schema: (text) -> (Result_4) query;
   zendb_collection_size: (text) -> (Result_3) query;
   zendb_collection_stats: (text) -> (Result_2) query;
   zendb_create_collection: (text, Schema) -> (Result_1);
   zendb_delete_collection: (text) -> (Result);
   zendb_get_database_name: () -> (text) query;
 };
type Candid__1 = 
 variant {
   Array: vec Candid__1;
   Blob: blob;
   Bool: bool;
   Empty;
   Float: float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: vec KeyValuePair;
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Null;
   Option: Candid__1;
   Principal: principal;
   Record: vec KeyValuePair;
   Text: text;
   Tuple: vec Candid__1;
   Variant: KeyValuePair;
 };
type CandidType = 
 variant {
   Array: CandidType;
   Blob;
   Bool;
   Empty;
   Float;
   Int;
   Int16;
   Int32;
   Int64;
   Int8;
   Map: vec record {
              text;
              CandidType;
            };
   Nat;
   Nat16;
   Nat32;
   Nat64;
   Nat8;
   Null;
   Option: CandidType;
   Principal;
   Record: vec record {
                 text;
                 CandidType;
               };
   Recursive: nat;
   Text;
   Tuple: vec CandidType;
   Variant: vec record {
                  text;
                  CandidType;
                };
 };
type CandidBlob = blob;
type Candid = 
 variant {
   Array: vec Candid__1;
   Blob: blob;
   Bool: bool;
   Empty;
   Float: float64;
   Int: int;
   Int16: int16;
   Int32: int32;
   Int64: int64;
   Int8: int8;
   Map: vec KeyValuePair;
   Maximum;
   Minimum;
   Nat: nat;
   Nat16: nat16;
   Nat32: nat32;
   Nat64: nat64;
   Nat8: nat8;
   Null;
   Option: Candid__1;
   Principal: principal;
   Record: vec KeyValuePair;
   Text: text;
   Tuple: vec Candid__1;
   Variant: KeyValuePair;
 };
service : (text) -> CanisterDB
